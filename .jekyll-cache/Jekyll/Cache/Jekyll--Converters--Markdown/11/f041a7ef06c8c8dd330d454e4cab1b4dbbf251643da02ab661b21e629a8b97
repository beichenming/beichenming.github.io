I"É#<p><code class="highlighter-rouge">åŸåˆ›æ–‡ç« è½¬è½½è¯·æ³¨æ˜å‡ºå¤„ï¼Œè°¢è°¢</code></p>

<hr />

<p>ä¸Šæ¬¡è®²äº†å…³äºï¼‹(void)loadçš„è¿è¡Œæµç¨‹è§£æï¼Œæ‰€ä»¥è‚¯å®šå°±æœ‰å¿…è¦æ¥è®²ä¸€ä¸‹+(void)initializeï¼Œå› ä¸ºå¤§å®¶éƒ½ä¼šæ‹¿è¿™ä¸¤ä¸ªå‡½æ•°åšæ¯”è¾ƒã€‚</p>

<h3 id="voidinitialize">+(void)initialize</h3>

<p>å®˜æ–¹çš„specæ˜¯è¿™ä¹ˆå®šä¹‰çš„ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses. The superclass implementation may be called multiple times if subclasses do not implement initializeâ€”the runtime will call the inherited implementationâ€”or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:

+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
}

Because initialize is called in a thread-safe manner and the order of initialize being called on different classes is not guaranteed, itâ€™s important to do the minimum amount of work necessary in initialize methods. Specifically, any code that takes locks that might be required by other classes in their initialize methods is liable to lead to deadlocks. Therefore you should not rely on initialize for complex initialization, and should instead limit it to straightforward, class local initialization.

Special Considerations
initialize is invoked only once per class. If you want to perform independent initialization for the class and for categories of the class, you should implement load methods.
</code></pre></div></div>
<p>ç”±æ­¤æˆ‘ä»¬å¯ä»¥çŸ¥é“ä»¥ä¸‹å‡ ç‚¹ï¼š</p>

<ul>
  <li>æ¯ä¸ªç±»çš„initializeåªä¼šæ‰§è¡Œä¸€æ¬¡ï¼Œåœ¨allocä¹‹å‰</li>
  <li>initializeæ˜¯çº¿ç¨‹å®‰å…¨çš„</li>
  <li>çˆ¶ç±»çš„è°ƒç”¨çš„ä¼šå…ˆäºå­ç±»è°ƒç”¨</li>
  <li>çˆ¶ç±»çš„è°ƒç”¨ä¼šè¢«æ‰§è¡Œå¤šæ¬¡ï¼Œå¦‚æœå­ç±»çš„initializeå‡½æ•°æ²¡æœ‰è¢«å®ç°</li>
  <li>ä¸éœ€è¦æ˜¾ç¤º[super initialize]çš„è°ƒç”¨</li>
</ul>

<p>é‚£ä¹ˆinitializeåœ¨æˆ‘ä»¬çš„runtimeä¸­åˆ°åº•æ˜¯æ€ä¹ˆæ‰§è¡Œçš„å‘¢ï¼Ÿ</p>

<p><code class="highlighter-rouge">æˆ‘ä»¬é€šè¿‡æ–­ç‚¹ä¼šå‘ç°åœ¨initializeæ‰§è¡Œä¹‹å‰ä¼šæœ‰ä¸€ä¸ª_class_initializeçš„å‡½æ•°è°ƒç”¨ï¼Œé€šè¿‡runtimeçš„æºç å°±ä¼šå‘ç°æœ‰ä¸€ä¸ª_class_initializeçš„å‡½æ•°ã€‚</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/***********************************************************************
* class_initialize.  Send the '+initialize' message on demand to any
* uninitialized class. Force initialization of superclasses first.
*
* Called only from _class_lookupMethodAndLoadCache (or itself).
**********************************************************************/
PRIVATE_EXTERN void _class_initialize(Class cls)
{
    Class supercls;
    BOOL reallyInitialize = NO;

    // Get the real class from the metaclass. The superclass chain 
    // hangs off the real class only.
    cls = _class_getNonMetaClass(cls);

    // Make sure super is done initializing BEFORE beginning to initialize cls.
    // See note about deadlock above.
    supercls = _class_getSuperclass(cls);
    if (supercls  &amp;&amp;  !_class_isInitialized(supercls)) {
        _class_initialize(supercls);
    }
    
    // Try to atomically set CLS_INITIALIZING.
    monitor_enter(&amp;classInitLock);
    if (!_class_isInitialized(cls) &amp;&amp; !_class_isInitializing(cls)) {
        _class_setInitializing(cls);
        reallyInitialize = YES;
    }
    monitor_exit(&amp;classInitLock);
    
    if (reallyInitialize) {
        // We successfully set the CLS_INITIALIZING bit. Initialize the class.
        
        // Record that we're initializing this class so we can message it.
        _setThisThreadIsInitializingClass(cls);
        
        // Send the +initialize message.
        // Note that +initialize is sent to the superclass (again) if 
        // this class doesn't implement +initialize. 2157218
        if (PrintInitializing) {
            _objc_inform("INITIALIZE: calling +[%s initialize]",
                         _class_getName(cls));
        }

        ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);

        if (PrintInitializing) {
            _objc_inform("INITIALIZE: finished +[%s initialize]",
                         _class_getName(cls));
        }        
        
        // Done initializing. 
        // If the superclass is also done initializing, then update 
        //   the info bits and notify waiting threads.
        // If not, update them later. (This can happen if this +initialize 
        //   was itself triggered from inside a superclass +initialize.)
        
        monitor_enter(&amp;classInitLock);
        if (!supercls  ||  _class_isInitialized(supercls)) {
            _finishInitializing(cls, supercls);
        } else {
            _finishInitializingAfter(cls, supercls);
        }
        monitor_exit(&amp;classInitLock);
        return;
    }
    
    else if (_class_isInitializing(cls)) {
        // We couldn't set INITIALIZING because INITIALIZING was already set.
        // If this thread set it earlier, continue normally.
        // If some other thread set it, block until initialize is done.
        // It's ok if INITIALIZING changes to INITIALIZED while we're here, 
        //   because we safely check for INITIALIZED inside the lock 
        //   before blocking.
        if (_thisThreadIsInitializingClass(cls)) {
            return;
        } else {
            monitor_enter(&amp;classInitLock);
            while (!_class_isInitialized(cls)) {
                monitor_wait(&amp;classInitLock);
            }
            monitor_exit(&amp;classInitLock);
            return;
        }
    }
    
    else if (_class_isInitialized(cls)) {
        // Set CLS_INITIALIZING failed because someone else already 
        //   initialized the class. Continue normally.
        // NOTE this check must come AFTER the ISINITIALIZING case.
        // Otherwise: Another thread is initializing this class. ISINITIALIZED 
        //   is false. Skip this clause. Then the other thread finishes 
        //   initialization and sets INITIALIZING=no and INITIALIZED=yes. 
        //   Skip the ISINITIALIZING clause. Die horribly.
        return;
    }
    
    else {
        // We shouldn't be here. 
        _objc_fatal("thread-safe class init in objc runtime is buggy!");
    }
}
</code></pre></div></div>
<p>æˆ‘ä»¬è§‚å¯Ÿè¿™ä¸ªå‡½æ•°å‘ç°ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    supercls = _class_getSuperclass(cls);
    if (supercls  &amp;&amp;  !_class_isInitialized(supercls)) {
        _class_initialize(supercls);
    }
</code></pre></div></div>
<p><code class="highlighter-rouge">å®ƒä¼šå»æ‰¾çˆ¶ç±»çš„initializeå…ˆæ‰§è¡Œï¼Œç„¶åå†å»æ‰§è¡Œå­ç±»çš„ï¼Œä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹ï¼Œè¿™å°±è§£é‡Šäº†ä¸ºä»€ä¹ˆçˆ¶ç±»çš„è°ƒç”¨çš„ä¼šå…ˆäºå­ç±»è°ƒç”¨ã€‚</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);
</code></pre></div></div>
<p><code class="highlighter-rouge">è¿™æ®µä»£ç å¾ˆé‡è¦ï¼Œè¯´æ˜äº†initializeçš„è°ƒç”¨ä¹Ÿæ˜¯å’Œå…¶ä»–å‡½æ•°ä¸€æ ·æ˜¯é€šè¿‡objc_msgSendçš„æ–¹å¼æ¥æ‰§è¡Œçš„ï¼Œè¿™å’Œloadå‡½æ•°çš„åŒºåˆ«åœ¨äºï¼Œloadæ˜¯è®°å½•äº†ä¸€ä¸ªè‡ªå·±çš„æ–¹æ³•åˆ—è¡¨ï¼Œä¾æ¬¡å»æ‰§è¡Œæ‰€æœ‰å·²æœ‰çš„æ–¹æ³•ï¼Œæ‰€ä»¥å³ä½¿å­ç±»æ²¡æœ‰å®ç°loadæ–¹æ³•ï¼Œå®ƒä¹Ÿä¸ä¼šå»è°ƒç”¨çˆ¶ç±»çš„æ–¹æ³•ï¼›ä½†æ˜¯initializeæ˜¯å¦‚æœå­ç±»æ²¡æœ‰å®ç°initializeæ–¹æ³•ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šè°ƒç”¨çˆ¶ç±»çš„å®ç°ï¼Œè¿™ä¸ªè¯æ˜äº†ä¸Šé¢æåˆ°çš„çˆ¶ç±»çš„è°ƒç”¨ä¼šè¢«æ‰§è¡Œå¤šæ¬¡ï¼Œå¦‚æœå­ç±»çš„initializeå‡½æ•°æ²¡æœ‰è¢«å®ç°çš„æƒ…å†µä¸‹ï¼Œè€Œä¸”å¦‚æœä¸€ä¸ªcateoryå®ç°äº†initializeæ–¹æ³•ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šè¦†ç›–åŸæ¥ç±»é‡Œçš„initializeæ–¹æ³•ï¼ˆåŒåæ–¹æ³•è¦†ç›–ï¼Œåªå–method_listé‡Œçš„æœ€ä¸Šå±‚çš„æ–¹æ³•ï¼‰ã€‚æœ€åå°±æ˜¯ç”±äºçˆ¶ç±»å¯èƒ½ä¼šè¢«æ‰§è¡Œå¤šæ¬¡ï¼Œæ‰€ä»¥ä¸ºäº†é¿å…å¤šæ¬¡æ‰§è¡Œå¯èƒ½å¸¦æ¥çš„å±å®³ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨specä¸Šçš„åšæ³•ï¼š</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
}
</code></pre></div></div>
<p>å¼•ç”¨ä¸€ä¸‹ç½‘ä¸Šå¯¹äºloadå’Œinitializeçš„åŒºåˆ«æ€»ç»“ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>               +load		  +initialize
è°ƒç”¨æ—¶æœº	    	è¢«æ·»åŠ åˆ°runtimeæ—¶	     æ”¶åˆ°ç¬¬ä¸€æ¡æ¶ˆæ¯å‰ï¼Œå¯èƒ½æ°¸è¿œä¸è°ƒç”¨

è°ƒç”¨é¡ºåº         çˆ¶ç±»-&gt;å­ç±»-&gt;åˆ†ç±»	  çˆ¶ç±»-&gt;å­ç±»

è°ƒç”¨æ¬¡æ•°	        1æ¬¡		 å¤šæ¬¡

æ˜¯å¦éœ€è¦æ˜¾å¼      å¦                  å¦
è°ƒç”¨çˆ¶ç±»å®ç°				

æ˜¯å¦æ²¿ç”¨         å¦                  æ˜¯
çˆ¶ç±»çš„å®ç°						

åˆ†ç±»ä¸­çš„å®ç°      ç±»å’Œåˆ†ç±»éƒ½æ‰§è¡Œ       è¦†ç›–ç±»ä¸­çš„æ–¹æ³•ï¼Œåªæ‰§è¡Œåˆ†ç±»çš„å®ç°
</code></pre></div></div>
:ET