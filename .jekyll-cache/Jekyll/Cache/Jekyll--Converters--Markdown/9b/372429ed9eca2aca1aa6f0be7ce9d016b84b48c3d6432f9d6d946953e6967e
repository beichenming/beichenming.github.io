I"­'<p><code class="highlighter-rouge">åŸåˆ›æ–‡ç« è½¬è½½è¯·æ³¨æ˜å‡ºå¤„ï¼Œè°¢è°¢</code></p>

<hr />

<p>ä¹‹å‰éƒ½æ²¡æœ‰å¾ˆç»†è‡´çš„å»äº†è§£è¿‡Categoryçš„è¿è¡ŒåŸç†ï¼Œä»Šå¤©æ­£å¥½æ˜¯å‘¨æœ«æ‰€ä»¥å°±ä»”ç»†äº†è§£äº†ä¸€ä¸‹ï¼Œç½‘ä¸Šå…¶å®æœ‰ä¸å°‘å¥½æ–‡éƒ½è¯¦ç»†ä»‹ç»äº†Categoryçš„åŸç†ï¼Œä¸è¿‡æˆ‘è¿˜æ˜¯æœ‰è‡ªå·±çš„ä¸€ç‚¹ç†è§£éœ€è¦è®²çš„ã€‚</p>

<p><code class="highlighter-rouge">Categoryæ˜¯è£…é¥°è€…æ¨¡å¼çš„ä¸€ç§ä½“ç°ï¼Œä¸»è¦ç”¨äºåœ¨ä¸æ”¹å˜åŸæœ‰ç±»çš„å‰æä¸‹ï¼ŒåŠ¨æ€çš„ç»™è¿™ä¸ªç±»æ·»åŠ ä¸€äº›æ–¹æ³•ï¼ŒåŒæ—¶å¯ä»¥å°†ä¸€ä¸ªç±»çš„å®ç°æ‹†åˆ†æˆå¤šä¸ªç‹¬ç«‹çš„æºæ–‡ä»¶ï¼Œæ–¹ä¾¿ç®¡ç†ã€‚ä½†æ˜¯ä¸å»ºè®®åœ¨Categoryä¸­æ·»åŠ å±æ€§ï¼Œè¿™é‡Œè¯´æ˜¯ä¸å»ºè®®çš„æ„æ€æ˜¯å…¶å®å¯ä»¥åœ¨Categoryé‡Œæ·»åŠ å±æ€§çš„ï¼Œä¸è¿‡éœ€è¦ä¸€äº›å¤„ç†ï¼Œæˆ‘åœ¨åé¢ä¼šè§£é‡Šã€‚</code></p>

<p>é¦–å…ˆæˆ‘ä»¬å®šä¹‰äº†AClassçš„ä¸€ä¸ªCategory ACategoryï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// AClass.h
@protocol AClass_protocol &lt;NSObject&gt;

- (void)protocolMethods_ACategory;

@end

@interface AClass : NSObject

@end

@interface AClass(ACategory)&lt;AClass_protocol&gt;

@property (nonatomic) NSString *address;

- (void)instanceMethods_ACategory;

+ (void)classMethods_ACategory;

@end

// AClass.m
@implementation AClass

@end

@implementation AClass (ACategory)

@dynamic address;

- (void)instanceMethods_ACategory {
    NSLog(@"instanceMethods_ACategory");
}

+ (void)classMethods_ACategory {
    NSLog(@"classMethods_ACategory");
}

- (void)protocolMethods_ACategory {
    NSLog(@"protocolMethods_ACategory");
}

@end

</code></pre></div></div>
<p>æˆ‘ä»¬åœ¨runtimeçš„æºç é‡Œå¯ä»¥çœ‹åˆ°Categoryçš„å®šä¹‰ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct category_t {
    const char *name; //ç±»çš„åå­—
    struct class_t *cls; //æŒ‡å‘çš„ç±»
    struct method_list_t *instanceMethods; //categoryä¸­æ‰€æœ‰ç»™ç±»æ·»åŠ çš„å®ä¾‹æ–¹æ³•çš„åˆ—è¡¨
    struct method_list_t *classMethods; //categoryä¸­æ‰€æœ‰æ·»åŠ çš„ç±»æ–¹æ³•çš„åˆ—è¡¨
    struct protocol_list_t *protocols; //categoryå®ç°çš„æ‰€æœ‰åè®®çš„åˆ—è¡¨
    struct property_list_t *instanceProperties; //categoryä¸­æ·»åŠ çš„æ‰€æœ‰å±æ€§
} category_t;
</code></pre></div></div>
<p>ç„¶åæˆ‘ä»¬ç¼–è¯‘ä¸€ä¸‹ä¸Šé¢çš„Categoryï¼Œclang -rewrite-objc AClass.mï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°AClass.cpp,é‡Œé¢åŒ…å«äº†å¦‚ä¸‹çš„å†…å®¹ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> static struct _category_t _OBJC_$_CATEGORY_AClass_$_ACategory __attribute__ ((used, section ("__DATA,__objc_const"))) = 
{
	"AClass",
	0, // &amp;OBJC_CLASS_$_AClass,
	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_AClass_$_ACategory,
	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_AClass_$_ACategory,
	(const struct _protocol_list_t *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_AClass_$_ACategory,
	(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_AClass_$_ACategory,
};
static void OBJC_CATEGORY_SETUP_$_AClass_$_ACategory(void ) {
	_OBJC_$_CATEGORY_AClass_$_ACategory.cls = &amp;OBJC_CLASS_$_AClass;
}

</code></pre></div></div>
<p>æˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„Categoryæœ€ç»ˆä¼šè¢«ç¼–è¯‘æˆè¿™ä¸ªæ ·å­ï¼Œä¸Šé¢çš„å››ä¸ªStructéƒ½å¯ä»¥æ‰¾åˆ°å¯¹åº”å®šä¹‰ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// _OBJC_$_CATEGORY_INSTANCE_METHODS_AClass_$_ACategory
static struct /*_method_list_t*/ {
	unsigned int entsize;  // sizeof(struct _objc_method)
	unsigned int method_count;
	struct _objc_method method_list[2];
} _OBJC_$_CATEGORY_INSTANCE_METHODS_AClass_$_ACategory __attribute__ ((used, section ("__DATA,__objc_const"))) = {
	sizeof(_objc_method),
	2,
	{
	{(struct objc_selector *)"instanceMethods_ACategory", "v16@0:8", (void *)_I_AClass_ACategory_instanceMethods_ACategory},
	{(struct objc_selector *)"protocolMethods_ACategory", "v16@0:8", (void *)_I_AClass_ACategory_protocolMethods_ACategory}}
};

// _OBJC_$_CATEGORY_CLASS_METHODS_AClass_$_ACategory
static struct /*_method_list_t*/ {
	unsigned int entsize;  // sizeof(struct _objc_method)
	unsigned int method_count;
	struct _objc_method method_list[1];
} _OBJC_$_CATEGORY_CLASS_METHODS_AClass_$_ACategory __attribute__ ((used, section ("__DATA,__objc_const"))) = {
	sizeof(_objc_method),
	1,
	
};

// _OBJC_CATEGORY_PROTOCOLS_$_AClass_$_ACategory
static struct /*_protocol_list_t*/ {
	long protocol_count;  // Note, this is 32/64 bit
	struct _protocol_t *super_protocols[1];
} _OBJC_CATEGORY_PROTOCOLS_$_AClass_$_ACategory __attribute__ ((used, section ("__DATA,__objc_const"))) = {
	1,
	&amp;_OBJC_PROTOCOL_AClass_protocol
};

// _OBJC_$_PROP_LIST_AClass_$_ACategory
static struct /*_prop_list_t*/ {
	unsigned int entsize;  // sizeof(struct _prop_t)
	unsigned int count_of_properties;
	struct _prop_t prop_list[1];
} _OBJC_$_PROP_LIST_AClass_$_ACategory __attribute__ ((used, section ("__DATA,__objc_const"))) = {
	sizeof(_prop_t),
	1,
	address
};


</code></pre></div></div>

<p>æˆ‘ä»¬å†æ¥çœ‹ä¸€ä¸‹ä¸¤ä¸ªCategoryçš„æ—¶å€™ç¼–è¯‘å‡ºæ¥çš„category_tç»“æ„ï¼Œå…¶å®å°±æ˜¯å¤šäº†ä¸€ä¸ªCategoryæ·»åŠ åˆ°æ•°ç»„é‡Œ:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [2] __attribute__((used, section ("__DATA, __objc_catlist,regular,no_dead_strip")))= {
	&amp;_OBJC_$_CATEGORY_AClass_$_ACategory1,
	&amp;_OBJC_$_CATEGORY_AClass_$_ACategory2,
};
</code></pre></div></div>

<p>å¥½äº†ï¼Œåˆ°ç°åœ¨ä¸ºæ­¢æˆ‘ä»¬æ­£å¼å¾—åˆ°äº†åœ¨runtimeä¹‹å‰çš„Categoryçš„ç»“æ„ï¼Œæ¥ä¸‹æ¥å°±æ˜¯åŠ è½½Categoryäº†ï¼Œè¿™é‡Œæˆ‘å°±ä¸è®²æ•´ä¸ªè¿‡ç¨‹äº†ï¼Œç½‘ä¸Šæœ‰å¾ˆå¤šè®²çš„ï¼Œå…·ä½“è¯´ä¸€ä¸‹Categoryå’ŒClassä¸­åŒåæ–¹æ³•çš„æ‰§è¡Œé¡ºåºçš„é—®é¢˜ï¼š</p>

<ul>
  <li>Categoryçš„æ–¹æ³•æ²¡æœ‰â€œå®Œå…¨æ›¿æ¢æ‰â€åŸæ¥ç±»å·²ç»æœ‰çš„æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœCategoryå’ŒåŸæ¥ç±»éƒ½æœ‰methodAï¼Œé‚£ä¹ˆCategoryé™„åŠ å®Œæˆä¹‹åï¼Œç±»çš„æ–¹æ³•åˆ—è¡¨é‡Œä¼šæœ‰ä¸¤ä¸ªmethodAã€‚</li>
  <li>Categoryçš„æ–¹æ³•è¢«æ”¾åˆ°äº†æ–°æ–¹æ³•åˆ—è¡¨çš„å‰é¢ï¼Œè€ŒåŸæ¥ç±»çš„æ–¹æ³•è¢«æ”¾åˆ°äº†æ–°æ–¹æ³•åˆ—è¡¨çš„åé¢ï¼Œè¿™ä¹Ÿå°±æ˜¯æˆ‘ä»¬å¹³å¸¸æ‰€è¯´çš„Categoryçš„æ–¹æ³•ä¼šâ€œè¦†ç›–â€æ‰åŸæ¥ç±»çš„åŒåæ–¹æ³•ï¼Œè¿™æ˜¯å› ä¸ºruntimeæ—¶åœ¨æŸ¥æ‰¾æ–¹æ³•çš„æ—¶å€™æ˜¯é¡ºç€æ–¹æ³•åˆ—è¡¨çš„é¡ºåºæŸ¥æ‰¾çš„ï¼Œå®ƒåªè¦ä¸€æ‰¾åˆ°å¯¹åº”åå­—çš„æ–¹æ³•å°±ä¼šåœæ­¢ã€‚</li>
</ul>

<p>ä¼šé€ æˆä¸Šé¢è¿™ä¸ªç»“æœçš„åŸå› ä¸»è¦æ˜¯å› ä¸ºä¸‹é¢è¿™ä¸ªå‡½æ•°ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static void 
attachMethodLists(class_t *cls, method_list_t **addedLists, int addedCount, 
                  BOOL methodsFromBundle, BOOL *inoutVtablesAffected)
{
    rwlock_assert_writing(&amp;runtimeLock);

    // Don't scan redundantly
    BOOL scanForCustomRR = !UseGC &amp;&amp; !cls-&gt;hasCustomRR();

    // Method list array is NULL-terminated.
    // Some elements of lists are NULL; we must filter them out.

    method_list_t **oldLists = cls-&gt;data()-&gt;methods;
    int oldCount = 0;
    if (oldLists) {
        while (oldLists[oldCount]) oldCount++;
    }
        
    int newCount = oldCount + 1;  // including NULL terminator
    for (int i = 0; i &lt; addedCount; i++) {
        if (addedLists[i]) newCount++;  // only non-NULL entries get added
    }

    method_list_t **newLists = (method_list_t **)
        _malloc_internal(newCount * sizeof(*newLists));

    // Add method lists to array.
    // Reallocate un-fixed method lists.
    // The new methods are PREPENDED to the method list array.

    newCount = 0;
    int i;
    for (i = 0; i &lt; addedCount; i++) {
        method_list_t *mlist = addedLists[i];
        if (!mlist) continue;

        // Fixup selectors if necessary
        if (!isMethodListFixedUp(mlist)) {
            mlist = fixupMethodList(mlist, methodsFromBundle);
        }

        // Scan for vtable updates
        if (inoutVtablesAffected  &amp;&amp;  !*inoutVtablesAffected) {
            uint32_t m;
            for (m = 0; m &lt; mlist-&gt;count; m++) {
                SEL sel = method_list_nth(mlist, m)-&gt;name;
                if (vtable_containsSelector(sel)) {
                    *inoutVtablesAffected = YES;
                    break;
                }
            }
        }

        // Scan for method implementations tracked by the class's flags
        if (scanForCustomRR) {
            uint32_t m;
            for (m = 0; m &lt; mlist-&gt;count; m++) {
                SEL sel = method_list_nth(mlist, m)-&gt;name;
                if (isRRSelector(sel)) {
                    cls-&gt;setHasCustomRR();
                    scanForCustomRR = NO;
                    break;
                }
            }
        }
        
        // Fill method list array
        newLists[newCount++] = mlist;
    }

    // Copy old methods to the method list array
    for (i = 0; i &lt; oldCount; i++) {
        newLists[newCount++] = oldLists[i];
    }
    if (oldLists) free(oldLists);

    // NULL-terminate
    newLists[newCount++] = NULL;
    cls-&gt;data()-&gt;methods = newLists;
}
</code></pre></div></div>

<p><code class="highlighter-rouge">è¿™ä¸ªå‡½æ•°çš„ä¸»è¦æ€æƒ³æ˜¯é‡æ–°åˆ›å»ºä¸€ä¸ªæ–¹æ³•åˆ—è¡¨ï¼Œç„¶åå…ˆæ·»åŠ newListï¼Œç„¶åå†æ·»åŠ oldListï¼Œå¦å¤–ç”±äºclassçš„ä¼˜å…ˆçº§è¦é«˜äºcategoryï¼Œæ‰€ä»¥categoryçš„åŒåæ–¹æ³•è‚¯å®šæ˜¯ä¼˜äºclassä¸­æ‰§è¡Œçš„ï¼Œè€Œç›¸åŒcategoryä¸­çš„åŒåæ–¹æ³•å°±è¦çœ‹ç¼–è¯‘é¡ºåºäº†ã€‚å…³äºcateoryä¸­loadæ–¹æ³•æˆ‘å·²ç»åœ¨ä¹‹å‰æœ‰æåˆ°è¿‡äº†ï¼Œæ‰€ä»¥å°±ä¸è®²äº†ã€‚</code></p>

<p><strong>å¥½è¯´åˆ°è¿™é‡Œï¼Œå…³äºCategoryçš„è¿è¡Œæµç¨‹å·²ç»è®²å®Œäº†ï¼Œå‰©ä¸‹æ¥çš„å°±æ˜¯å…³äºåœ¨Categoryä¸­å®šä¹‰å±æ€§çš„é—®é¢˜äº†ï¼Œå…¶å®æ˜¯ä¸å»ºè®®åœ¨Categoryä¸­å®šä¹‰å±æ€§çš„ï¼ŒEffective Object C2.0ä¸­çš„26æ¡ä¹Ÿè¯´äº†è¿™ä»¶äº‹ï¼Œå‹¿åœ¨åˆ†ç±»ä¸­å£°æ˜å±æ€§ï¼›ç”±äºå±æ€§åœ¨Categoryä¸­ä¸èƒ½è‡ªåŠ¨ç”Ÿæˆgetå’Œsetæ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å…ˆæŠŠå­˜å–æ–¹æ³•å£°æ˜æˆ@dynamicï¼Œç„¶ååœ¨runtimeçš„æ—¶å€™å»å®ç°å®ƒçš„getå’Œsetæ–¹æ³•ï¼Œé€šè¿‡objc_getAssociatedObjectå’Œobjc_setAssociatedObjectæ¥å®Œæˆï¼Œè¿™æ ·å°±å¯ä»¥å®ç°åœ¨Categoryä¸­å®šä¹‰å±æ€§äº†ã€‚ä½†æ˜¯è¿™æ˜¯ä¸ªä¸å»ºè®®çš„åšæ³•ï¼Œå®¹æ˜“åœ¨å†…å­˜ç®¡ç†ä¸Šå‡ºç°ä¸€äº›éš¾æ’æŸ¥çš„é—®é¢˜ã€‚</strong></p>
:ET