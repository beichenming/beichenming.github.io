---
layout: post
title: 关于原码，反码和补码的数学探究
subtitle:   "操作系统"
date:       2018-03-02 10:31:00
author:     "BCM"
header-img: "../../img/post-bg-2015.jpg"
tags:
    - 操作系统
---

`原创文章转载请注明出处，谢谢`

---

### 前沿

首先关于原码，反码和补码这三个概念最早接触是在大一上计算机组成原理的时候，那个时候为了应付考试，我想很多人只是记住了这三个名称的概念；但是对于这三个东西的发展过程以及数学自洽没有理解论证过，即使就算是讲课的老师也是照本宣科讲的模凌两可；

就在这几天在看汇编的时候无意间又接触到这块知识，所以干脆就去上网搜了一些资料，虽然发现网上很多博客都有介绍，看看细细品读之下发现很多文章里面包含了大量的错误信息（前提你要仔细去思考，就会发现这些文章的结论存在矛盾点），于是经过翻阅大量资料以后，我自己总结出了这篇文章的内容，我不敢说自己写的全对，也希望大家指证；

***备注：还有就是这篇文章不会从概念介绍开始，也就是不会讲什么是原码&&反码&&补码这些基础概念，这些网上很多大家自行补充；本文主要想讨论的是为什么计算机中所有的运算都是通过补码进行的，原码反码不行呢？***



### 计算机只能做加法
计算机在设计之初为了基本电路的考虑，所以让加减法都只需要用加法电路实现。关于这点我们以后在花时间仔细讲；

<mark>所以需要把减去一个正数或加上一个负数都用加上一个正数的方式来表示；</mark>


### 把减法通过加负数的方式进行计算

我们现在知道计算机都是通过加法的方式进行运算，也就是我们现在需要找个一个方法，使我们"加一个正数跟加一个负数(减一个正数) 一样的效果";

数学中我们有一个同余的概念，举例来说就是(这里引用了
***[这篇文章的一个例子](https://www.cnblogs.com/bellkosmos/p/7150105.html)***)：

**假设你对钟的时候如果发现它是6点，但实际上现在是2点，也就是它走快了4个小时，你可以有两种做法进行校正，一种是逆时针拨回4个小时到2点，另一种是顺时针拨6个小时到12点然后再拨2小时，也就是顺时针拨8个小时。也就是对于时钟的表盘来说，-4 = +8，同样还会有 -1 = +11，-5 = +7，甚至还有 -4 = +8 = +20 = +32 = -16**

**他们间隐藏了什么规律呢？在数学中，-4、+8、+20、+32、-16可以归为符合某个条件的同一类数字——对于模12同余。wiki上对于模的定义是 “两个整数a、b，若它们除以正整数m所得的余数相等，则称a、b对于模m同余”；**

**而在一个可溢出计数系统中，把计数系统容量作为模，那么所有对此模同余的数在此计数系统中都会有同样的表示（加这个数也一样）。比如时钟表盘就是一个可溢出计数系统，模为12；一个n位二进制构成的计数系统中，因为会舍弃溢出的高位，所以也是一个可溢出的计数系统，模为2^n（从0数到2^n-1）**

*同余定理有以下几个特性*：

>1.反身性：a≡a (mod m)；
>
>2.对称性：若a≡b(mod m)，则b≡a (mod m)；
>
>3.传递性：若a≡b(mod m)，b≡c(mod m)，则a≡c(mod m)；
>
>4.同余式相加：若a≡b(mod m)，c≡d(mod m)，则a±c≡b±d(mod m)；

**由此我们可以推导出:**


>a+c≡a+d(mod m)

>这里面的c就是我们那个负值；而d就是我们需要的那个正值；


**所以现在问题就变成了怎么求d这个值了**


> ∵ c≡d(mod m)

> ∴ d就可以是跟c对于模同余的正数；


<mark>那么接下来我们就出现了一个新的问题，那就是这个d又是怎么和补码扯上关系的；通过我们的结论反推可以发现其实d就是我们要找的补码；</mark>

### 如何求d（补码）

从之前我们知道了d就可以是跟c对于模同余的正数，更严谨的来说应该是最小的正数（防止溢出）；

我们用一个3位二进制进行举例；
> if a = 2, c = -3;
> 
> ∵ 2 - 3 = -1；
> 
> ∴ c = -3;
> 
> ∵ a+c≡a+d(mod m)
> 
> ∴ d = -3 mod 8 = 5;
> 
> ∴ 2 + 5 = 010(同余) + 101(同余) = 0111 = 7；
> 

**但是这和我们实际的值相比是错的，但是模的值是对的；原因就是因为c转化为d时丢了符号位；所以我们还是应该在最左边把符号位加上(相当于直接减了一个模)，这样的好处是：**
 
> 1. 在保持补码特性的前提下。也就是减一个数还是照样变成加一个数
> 
> 2. 增加正负的表示。能真正表示 -8~-1了，就只用看符号位是0还是1
> 
> 3. 还能让运算时不用另外区分符号位，直接把符号位当成值位进行运算，而结果的正负号自然会符合这个正负表示法（也就是符号位的进位和值位的进位都会自然地合理）（有一种理解方式是，把这个负号1当成减一个模）

<mark>具体来说是在左边加一个符号位，这个符号位不参与“补码”的运算，始终表示数的正负，但在加法运算中跟值位一样参与运算。加了一个这样的符号位的“补码”就是真正计算机中存储的补码了。<mark>

我们还是以上面这个例子进行计算：

> if a = 2, c = -3;
> 
> ∵ 2 - 3 = -1；
> 
> ∴ c = -3;
> 
> ∵ a+c≡a+d(mod m)
> 
> ∴ d = -3 mod 8 = 5;
> 
> 2 + 5 = 0010(同余) + 1101(同余) = 1111 = -1?;

<mark>所以1111其实是一个补码；但是这个补码为什么会等于-1呢；它到底是怎么计算出来的；这就是我们接下来要讨论的;<mark>


### 论证原码，补码，反码之前的关系

**总结我们的前面说的关于求解补码的方式，先求模，然后求最小正同余数；**

我们把公式列一下就是:

> if 用3位二进制值位[abc]表示一个不会造成溢出的负数F
> 
> ∵ F = - (a*2^2 + b*2^1 + c)(a,b,c ∈ {0,1})
> 
> ∵ F(补) = F + 2^3;
> 
> ∴ F(补) = - (a*2^2 + b*2^1 + c) + 2^3
> 
> ∴ F(补) = (4 - 4*a) + (2 - 2*b) + (1 - c) + 1
> 
> ∴ F(补) = (1 - a)*2^2 + (1 - b)*2^1 + (1 - c) + 1
> 
> ∵ F(反) = (1 - a)*2^2 + (1 - b)*2^1 + (1 - c)
> 
> ∴ F(补) = F(反) + 1


**通过上述的证明我们才发现，原来反码和补码的关系是这么来的；反码只是我们计算中间的一个过渡产品；**

<mark>所以之前我们计算的1111可以通过这个公式反推得出它就是-1；</mark>

### 其他线索

**下图是一幅将原码，反码，补码全部加在一起的坐标图，这是我在知乎上面看到的一个比较新颖的[思路](https://zhuanlan.zhihu.com/p/36036038)，有助于我们理解加法运算，无非就是X轴的相加；**

<p align="center">
<img src="../../../../img/technology/2018-03-02/pic_1.png" alt="change_pic" title="change_pic"/>
</p>


### 总结

网上有很多思路来解释反码和补码，但是我觉得有一个误区就是，他们都是知道有反码补码了以后才回过头来论证它们的正确性，这就变成了一个先有鸡和先有蛋的问题；

其实我们的本质无非就是设计一个方法，让计算机对减法也同样进行加法运算，反码只是我们计算过程中的一个辅助手段；并不向其他人说的存在+-0，需要去掉，从而发明了补码，不是这样的，反码的计算本身就存在错误，函数图就可以证明了；


　　
　　




　　










