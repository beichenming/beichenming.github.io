---
layout: post
title: 如果要我们设计计算机的减法器？
subtitle:   "操作系统"
date:       2018-04-02 11:31:00
author:     "BCM"
header-img: "../../img/post-bg-2015.jpg"
tags:
    - 操作系统
---

`原创文章转载请注明出处，谢谢`

---

### 前沿

之前的文章我们有聊到关于计算机中补码的由来，用以解决我们减法的运算；当时我们说了一个前提就是计算机在设计之初为了基本电路的考虑所有的运算都是通过加法来完成的；那为什么计算机中的运算不能通过减法进行运算呢？以下内容就是我对这方面的探究，如有不对望指正；

### 关于加法和减法的计算

**加法**

> 如何计算下面的式子
> 
>> 11 + 6 = ? 

如果我们用二进制加法计算上面的式子，那么把它列成式子应该是这样的：

```
  0 0 0 0  1 0 1 1
+ 0 0 0 0  0 1 1 0
------------------
  0 0 0 1  0 0 0 1
 
```

二进制加法的规则是**逢二进一**，当两位相加大于1时就需要我们**进位**；所以我们将加法可以分拆出两张加法表，分别是**加和表**和**进位表**；

```
|    加法表    |            |   加和表   |      |   进位表   |
| + | 0  | 1  |		   | + | 0 | 1 |      | + | 0 | 1 | 
---------------		   -------------      -------------
| 0 | 00 | 01 |		   | 0 | 0 | 1 |      | 0 | 0 | 0 |
---------------		   -------------      -------------
| 1 | 01 | 10 |		   | 1 | 1 | 0 |      | 1 | 0 | 1 |
---------------		   -------------      -------------

```

**减法**

> 如何计算下面的式子
> 
>> 11 - 6 = ? 
>

如果我们用二进制减法计算上面的式子，那么把它列成式子应该是这样的：

```
   0 0 0 0  1 0 1 1
-  0 0 0 0  0 1 1 0
-------------------
   0 0 0 0  0 1 0 1

```

显然我们对于二进制减法的规则应该是**借一当二**，当两位数相减无法够时就需要向上**借位**了，所以我们也可以将减法拆分出两张减法表，分别是**减差表**和**借位表**；

```
|    减法表    |            |    减差表  |      |   借位表  |
| - | 0  | 1  |		   | - | 0 | 1 |      | - | 0 | 1 | 
---------------		   -------------      -------------
| 0 | 00 | 01 |		   | 0 | 0 | 1 |      | 0 | 0 | 0 |
---------------		   -------------      -------------
| 1 | ?1 | 00 |		   | 1 | 1 | 0 |      | 1 | 1 | 0 |
---------------		   -------------      -------------

备注：由于相减是区分减数和被减数的，所以表中统一规定由上方的数减去左边数；

```


### 关于减法存在的问题

通过二进制的减法运算，我们发现减法有一个明显区别于加法的地方，那就是减法的运算存在两种情况，那就是**大数减小数**以及**小数减大数**两种情况，而两种情况对应的结果是不一样的；

**大数减小数**这种情况下我们是不需要向上借位的，也就是此时的**差位应该为1**，**借位则为0**；

**小数减大数**这种情况下我们是需要向上借位的，也就是此时的**差位应该为1**，**借位也为1**；

这里我们就会出现一个计算问题，也就是减法的运算结果，是基于**减数**和**被减数**的大小的；那么我们有什么办法可以避免上面说的这种情况呢？也就是保证不管是**大数减小数**还是**小数减大数**都统一处理成一种情况？

> 我们重新观察一下 11 - 6 = ？这个例子，我们有没有什么办法能够让它计算的时候保证不借位，永远都是**大数减小数**这种情况呢？我们将式子进行分解；
> 
> 
>>  11 - 6 = 11 - 6 + 16 - 16 
>> 
>>  11 - 6 = 11 + (15 - 6) + 1 - 16 
>> 
>>  11 - 6 = 1011 + (1111 - 0110) + 0001 - 16
>>  
>>  11 - 6 = 1011 + 1001 + 0001 - 16
>> 
>>  11 - 6 = 10101 - 10000
>> 
>>  11 - 6 = 0101
>> 
>>  11 - 6 = 5


我们发现可以通过对二进制减法进行**加减该值二进制的最大值**的操作，这样我们就能保证永远都是**大数减小数**；

但是如果是 6 - 11 = ？这种情况呢，我们应该怎么处理；

其实也很简单，无非就是-（11 - 6）；也就是**大数减小数**值的相反数，只是我们在计算之前需要判断两个数的大小；

这个时候我们就可以重新修改我们的减法表了;

```

|  减差表    |      |   借位表   |
| - | 0 | 1 |      | - | 0 | 1 | 
-------------      -------------
| 0 | 0 | 1 |      | 0 | 0 | 0 |
-------------      -------------
| 1 | 1 | 0 |      | 1 | 0 | 0 |	
-------------      -------------

```

通过我们观察发现减法的运算步骤可以分为以下几个部分：

> 1. 判断减数以及被减数的大小
> 
> 2. 减数按位取反，即1111 - 0110 = 1001的结果就是减数按位取反的结果
> 
> 3. 被减数+被减数按位取反的值，即1011 + 1001 = 10100
> 
> 4. 前值的结果+1，即10100 + 00001 = 10101
> 
> 5. 取前值的N-1位，即10101 - 10000 = 0101的结果就是被减数的前4位
>
> 6. 判断值是否需要取负值


### 首先需要一个加法计算器

总所周知在集成电路中通过高低电平信号形成了逻辑门的运算，而我们所知常见的几种逻辑门包括**或门**，**与门**，**非门**，**异或门**，**同或门**等;

> 这里我们需要引用一下它们的数学定义：
>>
>> 与门：当AB都为1时，F才为1，否则均为0
>>> 
>>> F = A*B
>> 
>> 或门：当AB都为0时，F才为0，否则均为1
>> 
>>> F = A+B
>> 
>> 非门：取A的相反值
>> 
>>> F = A'
>> 
>> 异或门：当AB相同时，F才为0，否则为1
>> 
>>> F = A⨁B = A'*B + A*B'
>> 
>> 同或门：当AB相同时，F才为1，否则为0
>> 
>>> F = A⨀B = A*B + A'*B'


通过我们对于减法的公式分解，我们在减法的计算中其实还是需要加法的参与，所以我们就必须先设计加法计算器才能完成我们的减法器；


通过观察我们发现加法的**加和表**和**进位表**分别对应了**异或门**和**与门**；那么我们如何将两者进行融合呢？

> ∵ S是半加和数，CO是进位数
> 
> ∴ S = A⨁B = A'*B + A*B'
> 
> ∴ CO = A*B


<p align="center">
<img src="../../../../img/technology/2018-04-02/pic_1.png" alt="change_pic" title="change_pic"/>
</p>


这也就是我们常说的半加器，之所以叫半加器是有原因的，它将两个1位二进制数相加，得出一个加和位和一个进位位，但是绝大多数二进制数是多于1位的。半加器没有做到的是将之前的加法可能产生的进位纳入下一次运算；如果我们以最右边的1+1相加为例，此时进位1，对于右边算起的第二列，由于进位位的存在，实际上需要将三个二进制数相加，而随后每一列的加法都是这样的，随后的每一列二进制数相加都需要将进位位算进来。


所以我们的半加器就需要能够增加计算前面进位的功能，也就是需要三个数进行相加；


我们将两个半加器和一个或门做如下组合；首先从最左边第一个半加器的输入 A 和输入 B 开始，其输出是一个加和及相应的进位。这个和必须与前一列的进位输入 CI 相加，然后再把它们输入到一个或门中。你可能会觉得，这里还需要一个半加器，这当然是可行的。但是如果你了解了所有的可能性之后，你会发现，两个半加器的进位输出是不会同时为 1 的。或门在这里已经足够，因为或门除了都为 1 的时候以外，其他情况下的结果和异或门结果相同。


> ∵ S是半加和数，CO是进位数, CI是前面的进位数，
> 
> ∴ S = A⨁B⨁CI = 
> 
> ∴ CO = A*B + (A⨁B)*CI



<p align="center">
<img src="../../../../img/technology/2018-04-02/pic_2.png" alt="change_pic" title="change_pic"/>
</p>


经过上面的显示，我们已经成功设计出一个全加法器；


### 设计一个减法计算器

通过上面的我们对于减法的计算流程可知，我们要做的第一步需要进行数值的比较，所以我们需要一个数值的比较器；

> 数值比较一共有三种情况，即A>B，A<B,A=B三种；
>
> F(A>B) = A*B'
>
> F(A<B) = A'*B
>
> F(A=B) = A'*B' +A*B
>

上面是一个简单的1位数值比较器，关于多位的大家可以参考[这篇文章](http://www.cediy.com/webHtml/Article/baseelect/450820051227124800.html);

有了数值比较器以后，我们就可以将这些组合起来，合成一个减法计算器；


### 总结

我们通过一个设计一个减法计算器就可以理解，为什么计算中只有加法来实现所有的运算；因为如果我们单独为计算器实现一个减法计算器，需要消耗计算机的性能要远远高于用加法；





















